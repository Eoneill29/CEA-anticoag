################################################################################
# PHP2670
# Spring 2023
# Andrew Huang
# HW3
################################################################################

library(tidyverse)
library(ggplot2)
library(gridExtra)
set.seed(2670)

################################################################################
# Section 1, Question 1

# Setup decision tree
q1_dtree <- function(p7, u_severe){
  ev_surgery = (0.09)*(0) + (0.91)*(u_severe)
  ev_treatment = (0.10)*(100) + (0.30)*(90) + (0.40)*(u_severe) + 
    0.20*((p7)*(100) + (0.30)*(90) + (0.33)*(u_severe) + (0.07)*(0))
  return(list(surgery = ev_surgery,
              treatment = ev_treatment))
}

q1_dtree(p7=0.3, u_severe=70)

# Forward MC simulation
n=10000
q1_sim_df <- data.frame(
  sim = seq(1,n),
  p7 = runif(n, min=0.2, max=0.4),
  u_severe = runif(n, min=50, max=90)
)

q1_sim <- unlist(t(mapply(q1_dtree, p7=q1_sim_df$p7, u_severe=q1_sim_df$u_severe)))
q1_sim_df <- q1_sim_df %>%
  mutate(ev_surgery = q1_sim[1:n],
         ev_treatment = q1_sim[(n+1):length(q1_sim)])
summary(q1_sim_df)

# Plot simulated values
grid.arrange(
  ggplot(q1_sim_df, aes(x=p7)) + geom_histogram() + xlab("Probability of surgery after treatment & full recovery"),
  ggplot(q1_sim_df, aes(x=u_severe)) + geom_histogram() + xlab("Utility of surviving with severe disability"),
  ncol=1
)

q1_sim_boxplot <- data.frame(ev=q1_sim, strat=c(rep("immediate surgery", n), rep("treatment", n)))
ggplot(q1_sim_boxplot, aes(y=ev, x=strat)) + geom_boxplot() + xlab("Strategy") + ylab("Expected Value")

################################################################################
# Section 2, Question 2b & c

# Cohort simulation
# Four states: disease free (H0), recurrence (R), disease free after recurrence (H1), death (D)
n_states = 4
v_names_states <- c("disease free", "recurrence", "disease free after recurrence", "death")
v_names_str <-c("OLA", "IC")

OLA_trans_mat <- matrix(c(0.75, 0.15, 0.00, 0.10,
                          0.00, 0.00, 0.90, 0.10,
                          0.55, 0.25, 0.00, 0.20,
                          0.00, 0.00, 0.00, 1.00),
                        ncol=4, nrow=4, byrow=TRUE)
colnames(OLA_trans_mat) <- rownames(OLA_trans_mat) <- v_names_states
print(OLA_trans_mat)
rowSums(OLA_trans_mat)

IC_trans_mat <- matrix(c(0.55, 0.30, 0.00, 0.15,
                         0.00, 0.00, 0.90, 0.10,
                         0.55, 0.25, 0.00, 0.20,
                         0.00, 0.00, 0.00, 1.00),
                       ncol=4, nrow=4, byrow=TRUE)
colnames(IC_trans_mat) <- rownames(IC_trans_mat) <- v_names_states
print(IC_trans_mat)
rowSums(IC_trans_mat)

# Iterative solution of time-independent cSTM
n_cycles = 10
n_cohort = 10000

m_M <- matrix(NA,
              nrow = (n_cycles + 1), ncol = n_states,
              dimnames = list(0:n_cycles, v_names_states))
m_M_OLA <- m_M
m_M_OLA[1,] <- c(0.75, 0.15, 0.00, 0.10) # initial state vector
m_M_IC <- m_M
m_M_IC[1,] <- c(0.55, 0.30, 0.00, 0.15) # initial state vector

for(t in 1:n_cycles){
  # For OLA
  m_M_OLA[t + 1, ] <- m_M_OLA[t, ] %*% OLA_trans_mat
  
  # For IC
  m_M_IC[t + 1, ] <- m_M_IC[t, ] %*% IC_trans_mat
}

print(round(m_M_OLA*n_cohort, digits=0))
print(round(m_M_IC*n_cohort, digits=0))

# Plot cohort trace per strategy
plot_trace <- function(m_M) {
  df_M      <- data.frame(Cycle = 0:n_cycles, m_M, check.names = F)
  df_M_long <- tidyr::gather(df_M, key = `Health State`, value, 2:ncol(df_M))
  df_M_long$`Health State` <- factor(df_M_long$`Health State`, levels = v_names_states)
  gg_trace <- ggplot(df_M_long, aes(x = Cycle, y = value, 
                                    color = `Health State`, linetype = `Health State`)) +
    geom_line(size = 1) +
    xlab("Cycle") +
    ylab("Proportion of the cohort") +
    ylim(0,1) +
    scale_x_continuous() + 
    theme_bw(base_size = 14) +
    theme(legend.position  = "bottom", 
          legend.background = element_rect(fill = NA)) 
  
  return(gg_trace) 
}

grid.arrange(
  plot_trace(m_M_OLA) + ggtitle("OLA strategy"),
  plot_trace(m_M_IC) + ggtitle("IC strategy"),
  ncol=1
)

################################################################################
# Section 2, Question 2d & e

# Micro simulation
# Model input
n.i   <- 10000                  # number of simulated individuals
n.t   <- 10                    # time horizon, 10 cycles
v.n   <- c("disease free", "recurrence", "disease free after recurrence", "death")  # the model states
n.s   <- length(v.n)           # the number of health states
v.Trt <- c("OLA", "IC") # store the strategy names

#### Probability function
# The Probs function that updates the transition probabilities of every cycle is shown below.
Probs_OLA <- function(M_it) { 
  # M_it:    health state occupied by individual i at cycle t (character variable)
  v.p.it <- rep(NA, n.s)     # create vector of state transition probabilities
  names(v.p.it) <- v.n       # name the vector
  # update v.p.it with the appropriate probabilities   
  v.p.it[M_it == "disease free"]  <- c(0.75, 0.15, 0.00, 0.10)          # transition probabilities when healthy
  v.p.it[M_it == "recurrence"] <- c(0.00, 0.00, 0.90, 0.10)                       # transition probabilities when recurrence
  v.p.it[M_it == "disease free after recurrence"] <- c(0.55, 0.25, 0.00, 0.20)    # transition probabilities when healthy after recurrence
  v.p.it[M_it == "death"]  <- c(0.00, 0.00, 0.00, 1.00)                                        # transition probabilities when dead   
  ifelse(sum(v.p.it) == 1, return(v.p.it), print("Probabilities do not sum to 1")) # return the transition probabilities or produce an error
}
Probs_IC <- function(M_it) { 
  # M_it:    health state occupied by individual i at cycle t (character variable)
  v.p.it <- rep(NA, n.s)     # create vector of state transition probabilities
  names(v.p.it) <- v.n       # name the vector
  # update v.p.it with the appropriate probabilities   
  v.p.it[M_it == "disease free"]  <- c(0.55, 0.30, 0.00, 0.15)          # transition probabilities when healthy
  v.p.it[M_it == "recurrence"] <- c(0.00, 0.00, 0.90, 0.10)                       # transition probabilities when recurrence
  v.p.it[M_it == "disease free after recurrence"] <- c(0.55, 0.25, 0.00, 0.20)    # transition probabilities when healthy after recurrence
  v.p.it[M_it == "death"]  <- c(0.00, 0.00, 0.00, 1.00)                                        # transition probabilities when dead   
  ifelse(sum(v.p.it) == 1, return(v.p.it), print("Probabilities do not sum to 1")) # return the transition probabilities or produce an error
}

# Simulation for OLA
# Store sim trace
m.M_OLA <- matrix(nrow = n.i, ncol = n.t + 1, 
              dimnames = list(paste("ind", 1:n.i, sep = " "), 
                              paste("cycle", 0:n.t, sep = " ")))
for (i in 1:n.i){
  # set the seed for every individual for the random number generator
  set.seed(2670 + i)
  # Step 1: specify initial health states per individual
  m.M_OLA[i, 1] <- sample(v.n, prob=c(0.75, 0.15, 0.00, 0.10), size=1)
  
  for (t in 1:n.t){
    # Step 2: calculate transition probabilities
    v.p <- Probs_OLA(m.M_OLA[i, t])
    # Step 3: sample health state at cycle t+1 and store it in m.M
    m.M_OLA[i, t+1] <- sample(v.n, prob=v.p, size=1)
  } # close loop for time cycles
} # close loop for individuals

# Simulation for IC
# Store sim trace
m.M_IC <- matrix(nrow = n.i, ncol = n.t + 1, 
                  dimnames = list(paste("ind", 1:n.i, sep = " "), 
                                  paste("cycle", 0:n.t, sep = " ")))
for (i in 1:n.i){
  # set the seed for every individual for the random number generator
  set.seed(2670 + i)
  # Step 1: specify initial health states per individual
  m.M_IC[i, 1] <- sample(v.n, prob=c(0.55, 0.30, 0.00, 0.15), size=1)
  
  for (t in 1:n.t){
    # Step 2: calculate transition probabilities
    v.p <- Probs_OLA(m.M_IC[i, t])
    # Step 3: sample health state at cycle t+1 and store it in m.M
    m.M_IC[i, t+1] <- sample(v.n, prob=v.p, size=1)
  } # close loop for time cycles
} # close loop for individuals

# Reporting in aggregate
df_OLA <- data.frame(matrix(nrow=n.s, ncol=n.t+1, 
                            dimnames = list(paste(v.n),
                                            paste("cycle", 0:n.t, sep = " "))))
for (col in 1:ncol(df_OLA)){
  df_OLA["disease free",col] = sum(m.M_OLA[,col]=="disease free")
  df_OLA["recurrence",col] = sum(m.M_OLA[,col]=="recurrence")
  df_OLA["disease free after recurrence",col] = sum(m.M_OLA[,col]=="disease free after recurrence")
  df_OLA["death",col] = sum(m.M_OLA[,col]=="death")
}
df_IC <- data.frame(matrix(nrow=n.s, ncol=n.t+1, 
                            dimnames = list(paste(v.n),
                                            paste("cycle", 0:n.t, sep = " "))))
for (col in 1:ncol(df_IC)){
  df_IC["disease free",col] = sum(m.M_IC[,col]=="disease free")
  df_IC["recurrence",col] = sum(m.M_IC[,col]=="recurrence")
  df_IC["disease free after recurrence",col] = sum(m.M_IC[,col]=="disease free after recurrence")
  df_IC["death",col] = sum(m.M_IC[,col]=="death")
}

t(df_OLA)
t(df_IC)

df_OLA_plt <- cbind(data.frame(t(df_OLA))[,]/rowSums(data.frame(t(df_OLA))[,]))
colnames(df_OLA_plt) <- v_names_states
df_IC_plt <- cbind(data.frame(t(df_IC))[,]/rowSums(data.frame(t(df_IC))[,]))
colnames(df_IC_plt) <- v_names_states

grid.arrange(
  plot_trace(df_OLA_plt) + ggtitle("OLA strategy"),
  plot_trace(df_IC_plt) + ggtitle("IC strategy"),
  ncol=1
)
